<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>≈†koln√≠k - ≈†koln√≠ poradce</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .app-container {
            width: 100%;
            max-width: 500px;
            height: 90vh;
            max-height: 700px;
            background: #ffffff;
            border-radius: 24px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            position: relative;
            z-index: 10;
        }

        .avatar-small {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .header-info h1 {
            color: white;
            font-size: 20px;
            font-weight: 600;
        }

        .header-info p {
            color: rgba(255,255,255,0.8);
            font-size: 13px;
        }

        .mode-toggle {
            margin-left: auto;
            display: flex;
            background: rgba(255,255,255,0.2);
            border-radius: 25px;
            padding: 4px;
        }

        .mode-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            background: transparent;
            color: rgba(255,255,255,0.7);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .mode-btn.active {
            background: white;
            color: #5a67d8;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .mode-btn:hover:not(.active) {
            background: rgba(255,255,255,0.1);
        }

        /* Content Area */
        .content-area {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        /* Text Chat View */
        .chat-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            transition: opacity 0.3s, transform 0.3s;
        }

        .chat-view.hidden {
            opacity: 0;
            transform: translateX(-100%);
            pointer-events: none;
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            background: #f7f8fc;
        }

        .message {
            max-width: 85%;
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 15px;
            line-height: 1.5;
            animation: messageIn 0.3s ease-out;
        }

        @keyframes messageIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 6px;
        }

        .message.bot {
            background: white;
            color: #333;
            align-self: flex-start;
            border-bottom-left-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .message.typing {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 16px 20px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            background: #5a67d8;
            border-radius: 50%;
            animation: typingBounce 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) { animation-delay: 0s; }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typingBounce {
            0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }

        /* Input Area */
        .input-area {
            padding: 15px 20px;
            background: white;
            border-top: 1px solid #eee;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .text-input {
            flex: 1;
            padding: 12px 18px;
            border: 2px solid #e8e8e8;
            border-radius: 25px;
            font-size: 15px;
            outline: none;
            transition: border-color 0.3s;
        }

        .text-input:focus {
            border-color: #5a67d8;
        }

        .send-btn {
            width: 48px;
            height: 48px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .send-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(90, 103, 216, 0.4);
        }

        .send-btn:active {
            transform: scale(0.95);
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* 3D View */
        .model-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            transition: opacity 0.3s, transform 0.3s;
        }

        .model-view.hidden {
            opacity: 0;
            transform: translateX(100%);
            pointer-events: none;
        }

        #scene-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .model-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }

        .model-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        #mic-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        #mic-btn:hover {
            transform: scale(1.1);
        }

        #mic-btn.recording {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            50% { box-shadow: 0 0 0 15px rgba(220, 53, 69, 0); }
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
        }

        .spinner {
            border: 4px solid rgba(255,255,255,0.2);
            border-top: 4px solid #69db7c;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #recording-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(220, 53, 69, 0.9);
            padding: 10px 20px;
            border-radius: 25px;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            color: white;
            font-weight: 600;
        }

        #recording-indicator.active {
            opacity: 1;
        }

        .rec-dot {
            width: 10px;
            height: 10px;
            background: white;
            border-radius: 50%;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        #model-status {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #model-status.active {
            opacity: 1;
        }

        /* Welcome message */
        .welcome-message {
            text-align: center;
            padding: 30px;
            color: #666;
        }

        .welcome-message .emoji {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .welcome-message h2 {
            color: #333;
            margin-bottom: 10px;
        }

        /* Scrollbar */
        .messages-container::-webkit-scrollbar {
            width: 6px;
        }

        .messages-container::-webkit-scrollbar-track {
            background: transparent;
        }

        .messages-container::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }
    </style>
</head>
<body>
<div class="app-container">
    <!-- Header -->
    <div class="header">
        <div class="avatar-small">üéì</div>
        <div class="header-info">
            <h1>≈†koln√≠k</h1>
            <p>≈†koln√≠ poradce</p>
        </div>
        <div class="mode-toggle">
            <button class="mode-btn active" id="chat-mode-btn" onclick="switchMode('chat')">
                üí¨ Chat
            </button>
            <button class="mode-btn" id="model-mode-btn" onclick="switchMode('model')">
                üßë 3D
            </button>
        </div>
    </div>

    <!-- Content Area -->
    <div class="content-area">
        <!-- Text Chat View -->
        <div class="chat-view" id="chat-view">
            <div class="messages-container" id="messages">
                <div class="welcome-message">
                    <div class="emoji">üëã</div>
                    <h2>Ahoj!</h2>
                    <p>Jsem ≈†koln√≠k, tv≈Øj ≈°koln√≠ poradce. Pomohu ti vybrat tu spr√°vnou st≈ôedn√≠ ≈°kolu v Plze≈àsk√©m kraji. Na co se chce≈° zeptat?</p>
                </div>
            </div>
            <div class="input-area">
                <input type="text" class="text-input" id="text-input" placeholder="Napi≈° zpr√°vu..." onkeypress="handleKeyPress(event)">
                <button class="send-btn" id="send-btn" onclick="sendMessage()">‚û§</button>
            </div>
        </div>

        <!-- 3D Model View -->
        <div class="model-view hidden" id="model-view">
            <div id="scene-container">
                <div id="recording-indicator">
                    <div class="rec-dot"></div>
                    <span>Nahr√°v√°m...</span>
                </div>

                <div id="loading">
                    <div class="spinner"></div>
                    <p>Naƒç√≠t√°n√≠ 3D modelu...</p>
                </div>

                <div id="model-status"></div>

                <div class="model-controls">
                    <button class="model-btn" id="mic-btn" onclick="toggleRecording()">üé§</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const API = 'http://localhost:5000';
    const AVATAR_FILE = 'brunette.glb';
    const SESSION_ID = 'session_' + Date.now();

    let currentMode = 'chat';
    let isWaitingForResponse = false;

    // 3D Model variables
    let model = null;
    let mixer = null;
    let morphMeshes = [];
    let isSpeaking = false;
    let mouthOpenValue = 0;
    let scene, camera, renderer;
    let modelLoaded = false;

    let audioContext = null;
    let analyser = null;
    let dataArray = null;

    let blinkTimer = 0;
    let nextBlinkTime = 3;

    let mediaRecorder = null;
    let chunks = [];
    let isRecording = false;

    // ============================================
    // MODE SWITCHING
    // ============================================
    function switchMode(mode) {
        currentMode = mode;

        const chatView = document.getElementById('chat-view');
        const modelView = document.getElementById('model-view');
        const chatBtn = document.getElementById('chat-mode-btn');
        const modelBtn = document.getElementById('model-mode-btn');

        if (mode === 'chat') {
            chatView.classList.remove('hidden');
            modelView.classList.add('hidden');
            chatBtn.classList.add('active');
            modelBtn.classList.remove('active');
        } else {
            chatView.classList.add('hidden');
            modelView.classList.remove('hidden');
            chatBtn.classList.remove('active');
            modelBtn.classList.add('active');

            // Initialize 3D scene if not already
            if (!modelLoaded) {
                init3DScene();
            }
        }
    }

    // ============================================
    // TEXT CHAT FUNCTIONS
    // ============================================
    function handleKeyPress(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            sendMessage();
        }
    }

    function addMessage(text, isUser) {
        const messages = document.getElementById('messages');

        // Remove welcome message if exists
        const welcome = messages.querySelector('.welcome-message');
        if (welcome) welcome.remove();

        const msg = document.createElement('div');
        msg.className = `message ${isUser ? 'user' : 'bot'}`;
        msg.textContent = text;
        messages.appendChild(msg);
        messages.scrollTop = messages.scrollHeight;
    }

    function showTypingIndicator() {
        const messages = document.getElementById('messages');
        const typing = document.createElement('div');
        typing.className = 'message bot typing';
        typing.id = 'typing-indicator';
        typing.innerHTML = '<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>';
        messages.appendChild(typing);
        messages.scrollTop = messages.scrollHeight;
    }

    function removeTypingIndicator() {
        const typing = document.getElementById('typing-indicator');
        if (typing) typing.remove();
    }

    async function sendMessage() {
        const input = document.getElementById('text-input');
        const text = input.value.trim();

        if (!text || isWaitingForResponse) return;

        addMessage(text, true);
        input.value = '';

        isWaitingForResponse = true;
        document.getElementById('send-btn').disabled = true;

        showTypingIndicator();

        try {
            const response = await fetch(`${API}/__ai_stream__?prompt=${encodeURIComponent(text)}&session=${SESSION_ID}`);
            const reader = response.body.getReader();
            const decoder = new TextDecoder();

            removeTypingIndicator();

            // Create bot message element
            const messages = document.getElementById('messages');
            const botMsg = document.createElement('div');
            botMsg.className = 'message bot';
            messages.appendChild(botMsg);

            let fullText = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value);
                const lines = chunk.split('\n');

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const data = JSON.parse(line.substring(6));
                            if (data.text) {
                                fullText += data.text;
                                botMsg.textContent = fullText;
                                messages.scrollTop = messages.scrollHeight;
                            }
                            if (data.done && data.full) {
                                botMsg.textContent = data.full;
                            }
                        } catch (e) {}
                    }
                }
            }

        } catch (error) {
            console.error('Error:', error);
            removeTypingIndicator();
            addMessage('Omlouv√°m se, nƒõco se pokazilo. Zkus to pros√≠m znovu.', false);
        }

        isWaitingForResponse = false;
        document.getElementById('send-btn').disabled = false;
    }

    // ============================================
    // 3D SCENE INITIALIZATION
    // ============================================
    function init3DScene() {
        const container = document.getElementById('scene-container');

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(30, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 1.5, 1.2);
        camera.lookAt(0, 1.5, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        container.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
        keyLight.position.set(1, 2, 2);
        scene.add(keyLight);

        const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight.position.set(-1, 1, 2);
        scene.add(fillLight);

        const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
        backLight.position.set(0, 1, -2);
        scene.add(backLight);

        // Load model
        const loader = new THREE.GLTFLoader();
        loader.load(
            AVATAR_FILE,
            function(gltf) {
                model = gltf.scene;
                model.position.set(0, 0, 0);
                scene.add(model);

                model.traverse((child) => {
                    if (child.isMesh && child.morphTargetInfluences && child.morphTargetDictionary) {
                        morphMeshes.push(child);
                    }
                });

                if (gltf.animations && gltf.animations.length > 0) {
                    mixer = new THREE.AnimationMixer(model);
                    const idleAnim = gltf.animations.find(a =>
                        a.name.toLowerCase().includes('idle')
                    ) || gltf.animations[0];

                    if (idleAnim) {
                        mixer.clipAction(idleAnim).play();
                    }
                }

                document.getElementById('loading').style.display = 'none';
                modelLoaded = true;
            },
            function(xhr) {
                const percent = Math.round(xhr.loaded / xhr.total * 100);
                document.getElementById('loading').innerHTML =
                    '<div class="spinner"></div><p>Naƒç√≠t√°n√≠... ' + percent + '%</p>';
            },
            function(error) {
                console.error('Error:', error);
                document.getElementById('loading').innerHTML =
                    '<p>Chyba naƒç√≠t√°n√≠ modelu</p><small>Zkontroluj, ≈æe ' + AVATAR_FILE + ' je ve stejn√© slo≈æce</small>';
            }
        );

        // Start animation loop
        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            if (currentMode === 'model') {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        });
    }

    // ============================================
    // 3D ANIMATION
    // ============================================
    const MOUTH_MORPH_NAMES = [
        'mouthOpen', 'jawOpen', 'viseme_aa', 'viseme_O', 'viseme_U', 'A', 'O', 'MouthOpen'
    ];

    function setMouthOpen(value) {
        morphMeshes.forEach(mesh => {
            const dict = mesh.morphTargetDictionary;

            // –û—Å–Ω–æ–≤–Ω–æ–µ –æ—Ç–∫—Ä—ã—Ç–∏–µ
            if (dict['jawOpen'] !== undefined) {
                mesh.morphTargetInfluences[dict['jawOpen']] = value * 0.8;
            }
            if (dict['mouthOpen'] !== undefined) {
                mesh.morphTargetInfluences[dict['mouthOpen']] = value * 0.5;
            }

            // –§–æ—Ä–º–∞ –≥—É–±
            if (dict['viseme_aa'] !== undefined) {
                mesh.morphTargetInfluences[dict['viseme_aa']] = value * 0.4;
            }
            if (dict['viseme_O'] !== undefined) {
                mesh.morphTargetInfluences[dict['viseme_O']] = value * 0.3;
            }
        });
    }

    function animateMouth() {
        if (isSpeaking && analyser && dataArray) {
            analyser.getByteFrequencyData(dataArray);
            const volume = dataArray.reduce((a, b) => a + b, 0) / dataArray.length / 255;
            const target = Math.min(volume * 1.5, 0.5);
            mouthOpenValue += (target - mouthOpenValue) * 0.3;
        } else if (isSpeaking) {
            const target = 0.15 + Math.random() * 0.2;
            mouthOpenValue += (target - mouthOpenValue) * 0.25;
        } else {
            mouthOpenValue *= 0.85;
            if (mouthOpenValue < 0.01) mouthOpenValue = 0;
        }

        setMouthOpen(mouthOpenValue);
    }

    function animateBlink(delta) {
        blinkTimer += delta;

        if (blinkTimer > nextBlinkTime) {
            blinkTimer = 0;
            nextBlinkTime = 2 + Math.random() * 4;

            morphMeshes.forEach(mesh => {
                const dict = mesh.morphTargetDictionary;
                const influences = mesh.morphTargetInfluences;

                ['eyesClosed', 'eyeBlinkLeft', 'eyeBlinkRight', 'eyeBlink'].forEach(name => {
                    if (dict[name] !== undefined) {
                        influences[dict[name]] = 1.0;
                        setTimeout(() => { influences[dict[name]] = 0; }, 120);
                    }
                });
            });
        }
    }

    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        if (currentMode !== 'model') return;

        const delta = clock.getDelta();

        if (mixer) mixer.update(delta);
        animateMouth();
        animateBlink(delta);

        if (model && isSpeaking) {
            model.rotation.y = Math.sin(Date.now() * 0.002) * 0.03;
            model.rotation.x = Math.sin(Date.now() * 0.0015) * 0.015;
        } else if (model) {
            model.rotation.y *= 0.95;
            model.rotation.x *= 0.95;
        }

        renderer.render(scene, camera);
    }

    // ============================================
    // 3D MODEL STATUS
    // ============================================
    function showModelStatus(text) {
        const status = document.getElementById('model-status');
        status.textContent = text;
        status.classList.add('active');
    }

    function hideModelStatus() {
        document.getElementById('model-status').classList.remove('active');
    }

    // ============================================
    // TEXT-TO-SPEECH
    // ============================================
    async function speak(text) {
        if (!text || text.trim().length === 0) return;

        showModelStatus('Mluv√≠m...');

        try {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            dataArray = new Uint8Array(analyser.frequencyBinCount);

            const response = await fetch(API + '/tts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: text })
            });

            if (!response.ok) {
                throw new Error('TTS error: ' + response.status);
            }

            const audioData = await response.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(audioData);

            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(analyser);
            analyser.connect(audioContext.destination);

            isSpeaking = true;

            source.onended = () => {
                isSpeaking = false;
                hideModelStatus();
            };

            source.start(0);

        } catch (error) {
            console.error('TTS error:', error);
            isSpeaking = false;
            hideModelStatus();
        }
    }

    // ============================================
    // VOICE RECORDING
    // ============================================
    window.toggleRecording = async function() {
        const btn = document.getElementById('mic-btn');
        const indicator = document.getElementById('recording-indicator');

        if (!isRecording) {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                chunks = [];

                mediaRecorder.ondataavailable = e => chunks.push(e.data);

                mediaRecorder.onstop = async () => {
                    const blob = new Blob(chunks, { type: 'audio/webm' });
                    stream.getTracks().forEach(t => t.stop());

                    indicator.classList.remove('active');
                    btn.classList.remove('recording');

                    await processAudio(blob);
                };

                mediaRecorder.start();
                isRecording = true;
                btn.classList.add('recording');
                indicator.classList.add('active');

            } catch (err) {
                console.error('Microphone error:', err);
                alert('Nelze z√≠skat p≈ô√≠stup k mikrofonu');
            }
        } else {
            mediaRecorder.stop();
            isRecording = false;
        }
    };

    async function processAudio(blob) {
        showModelStatus('Rozpozn√°v√°m ≈ôeƒç...');

        try {
            const form = new FormData();
            form.append('audio', blob, 'audio.webm');

            const sttResponse = await fetch(API + '/stt', {
                method: 'POST',
                body: form
            });
            const sttData = await sttResponse.json();

            if (sttData.error) {
                console.error('STT error:', sttData.error);
                hideModelStatus();
                return;
            }

            await getAIResponseVoice(sttData.text);

        } catch (error) {
            console.error('Error:', error);
            hideModelStatus();
        }
    }

    async function getAIResponseVoice(userText) {
        try {
            showModelStatus('P≈ôem√Ω≈°l√≠m...');

            const response = await fetch(API + '/__ai__?prompt=' + encodeURIComponent(userText) + '&session=' + SESSION_ID);
            const data = await response.json();

            await speak(data.output);

        } catch (error) {
            console.error('Error:', error);
            hideModelStatus();
        }
    }
</script>
</body>
</html>
