<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <title>3D Hlasov√Ω chat</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            overflow: hidden;
        }
        
        #scene-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        /* –ö–Ω–æ–ø–∫–∏ –≤–Ω–∏–∑—É */
        .controls {
            position: absolute;
            bottom: 40px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 30%;  /* –ï—â—ë –±–ª–∏–∂–µ –∫ —Ü–µ–Ω—Ç—Ä—É */
            pointer-events: none;
        }
        
        .controls button {
            pointer-events: all;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            font-size: 32px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        /* –ú–∏–∫—Ä–æ—Ñ–æ–Ω (—Å–ª–µ–≤–∞) */
        #mic-btn {
            background: #28a745;
            color: white;
        }
        #mic-btn:hover {
            background: #218838;
            transform: scale(1.1);
        }
        #mic-btn.recording {
            background: #dc3545;
            animation: pulse 1.5s infinite;
        }
        
        /* –ö—Ä–µ—Å—Ç–∏–∫ (—Å–ø—Ä–∞–≤–∞) */
        #close-btn {
            background: #dc3545;
            color: white;
        }
        #close-btn:hover {
            background: #c82333;
            transform: scale(1.1);
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            50% { box-shadow: 0 0 0 15px rgba(220, 53, 69, 0); }
        }
        
        /* –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–ø–∏—Å–∏ */
        #recording-indicator {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(220, 53, 69, 0.9);
            padding: 12px 25px;
            border-radius: 25px;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            color: white;
            font-weight: bold;
        }
        #recording-indicator.active {
            opacity: 1;
        }
        .rec-dot {
            width: 10px;
            height: 10px;
            background: white;
            border-radius: 50%;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            text-align: center;
            color: white;
        }
        .spinner {
            border: 4px solid #333;
            border-top: 4px solid #69db7c;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="scene-container">
        <!-- –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–ø–∏—Å–∏ -->
        <div id="recording-indicator">
            <div class="rec-dot"></div>
            <span>Nahr√°v√°m...</span>
        </div>
        
        <div id="loading">
            <div class="spinner"></div>
            Naƒç√≠t√°n√≠...
        </div>
        
        <!-- –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
        <div class="controls">
            <button id="mic-btn" onclick="toggleRecording()">üé§</button>
            <button id="close-btn" onclick="closeApp()">‚úï</button>
        </div>
    </div>

    <!-- Three.js + GLTFLoader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // ============================================
        // KONFIGURACE
        // ============================================
        const API = 'http://flask:5000';
        const AVATAR_FILE = 'brunette.glb';  // Tv≈Øj GLB soubor
        
        // ============================================
        // GLOB√ÅLN√ç PROMƒöNN√â
        // ============================================
        let model = null;
        let mixer = null;
        let morphMeshes = [];  // Meshe s morph targets (pro animaci √∫st)
        let isSpeaking = false;
        let mouthOpenValue = 0;
        let targetMouthValue = 0;
        
        // Audio analyzer –¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏ —Ä—Ç–∞
        let audioContext = null;
        let analyser = null;
        let dataArray = null;
        
        // –ê–Ω–∏–º–∞—Ü–∏—è –≥–ª–∞–∑ –∏ –≥–æ–ª–æ–≤—ã
        let blinkTimer = 0;
        let nextBlinkTime = 3;
        let headRotation = { x: 0, y: 0 };
        
        let mediaRecorder = null;
        let chunks = [];
        let isRecording = false;
        
        // –ó–∞–∫—Ä—ã—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
        window.closeApp = function() {
            if (confirm('Ukonƒçit aplikaci?')) {
                window.close();
                // –ï—Å–ª–∏ –Ω–µ –∑–∞–∫—Ä—ã–ª–æ—Å—å (–±—Ä–∞—É–∑–µ—Ä –±–ª–æ–∫–∏—Ä—É–µ—Ç) - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
                setTimeout(() => {
                    alert('Zav≈ôete kartu prohl√≠≈æeƒçe ruƒçnƒõ');
                }, 100);
            }
        };

        // ============================================
        // 3D SC√âNA
        // ============================================
        const container = document.getElementById('scene-container');
        const scene = new THREE.Scene();
        
        // Kamera - zamƒõ≈ôen√° na obliƒçej
        const camera = new THREE.PerspectiveCamera(
            30, 
            container.clientWidth / container.clientHeight, 
            0.1, 
            1000
        );
        camera.position.set(0, 1.5, 1.2);  // –û—Ç–¥–∞–ª–∏–ª –∫–∞–º–µ—Ä—É
        camera.lookAt(0, 1.5, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        container.appendChild(renderer.domElement);

        // Svƒõtla
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
        keyLight.position.set(1, 2, 2);
        scene.add(keyLight);

        const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight.position.set(-1, 1, 2);
        scene.add(fillLight);

        const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
        backLight.position.set(0, 1, -2);
        scene.add(backLight);

        // ============================================
        // NAƒåTEN√ç MODELU
        // ============================================
        const loader = new THREE.GLTFLoader();
        loader.load(
            AVATAR_FILE,
            function(gltf) {
                model = gltf.scene;
                model.position.set(0, 0, 0);
                scene.add(model);

                // Najdi v≈°echny meshe s morph targets
                model.traverse((child) => {
                    if (child.isMesh && child.morphTargetInfluences && child.morphTargetDictionary) {
                        morphMeshes.push(child);
                        console.log('Morph mesh:', child.name);
                        console.log('Morph targets:', Object.keys(child.morphTargetDictionary));
                    }
                });

                // Animace pokud existuj√≠
                if (gltf.animations && gltf.animations.length > 0) {
                    mixer = new THREE.AnimationMixer(model);
                    const idleAnim = gltf.animations.find(a => 
                        a.name.toLowerCase().includes('idle')
                    ) || gltf.animations[0];
                    
                    if (idleAnim) {
                        const action = mixer.clipAction(idleAnim);
                        action.play();
                    }
                }

                document.getElementById('loading').style.display = 'none';
                console.log('Model naƒçten √∫spƒõ≈°nƒõ!');
            },
            function(xhr) {
                const percent = Math.round(xhr.loaded / xhr.total * 100);
                document.getElementById('loading').innerHTML = 
                    `<div class="spinner"></div>Naƒç√≠t√°n√≠... ${percent}%`;
            },
            function(error) {
                console.error('Chyba:', error);
                document.getElementById('loading').innerHTML = 
                    `‚ùå Chyba naƒç√≠t√°n√≠<br><small>Vlo≈æ ${AVATAR_FILE} do stejn√© slo≈æky</small>`;
            }
        );

        // ============================================
        // ANIMACE √öST (MORPH TARGETS)
        // ============================================
        
        // Mo≈æn√© n√°zvy morph targets pro otev≈ôen√≠ √∫st
        const MOUTH_MORPH_NAMES = [
            'mouthOpen',
            'jawOpen', 
            'viseme_aa',
            'viseme_O',
            'viseme_U',
            'A',
            'O',
            'MouthOpen'
        ];

        function setMouthOpen(value) {
            morphMeshes.forEach(mesh => {
                const dict = mesh.morphTargetDictionary;
                
                // Zkus naj√≠t morph target pro √∫sta
                for (const name of MOUTH_MORPH_NAMES) {
                    if (dict[name] !== undefined) {
                        mesh.morphTargetInfluences[dict[name]] = value;
                    }
                }
                
                // Oculus visemes - kombinuj pro realistiƒçtƒõj≈°√≠ efekt
                if (dict['viseme_aa'] !== undefined) {
                    mesh.morphTargetInfluences[dict['viseme_aa']] = value * 0.7;
                }
                if (dict['viseme_O'] !== undefined) {
                    mesh.morphTargetInfluences[dict['viseme_O']] = value * 0.3;
                }
            });
        }

        // –ê–Ω–∏–º–∞—Ü–∏—è —Ä—Ç–∞ - —Å –∞–Ω–∞–ª–∏–∑–æ–º –≥—Ä–æ–º–∫–æ—Å—Ç–∏
        function animateMouth() {
            if (isSpeaking && analyser && dataArray) {
                // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≥—Ä–æ–º–∫–æ—Å—Ç—å –∞—É–¥–∏–æ
                analyser.getByteFrequencyData(dataArray);
                const volume = dataArray.reduce((a, b) => a + b, 0) / dataArray.length / 255;
                
                // –¶–µ–ª–µ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç–∏—è —Ä—Ç–∞ = –≥—Ä–æ–º–∫–æ—Å—Ç—å (—É—Å–∏–ª–µ–Ω–Ω–∞—è)
                const target = Math.min(volume * 3.0, 0.9);
                
                // –ü–ª–∞–≤–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥
                mouthOpenValue += (target - mouthOpenValue) * 0.35;
                
            } else if (isSpeaking) {
                // –§–æ–ª–±—ç–∫ –µ—Å–ª–∏ –Ω–µ—Ç –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–∞ - —Å–ª—É—á–∞–π–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è
                const target = 0.3 + Math.random() * 0.5;
                mouthOpenValue += (target - mouthOpenValue) * 0.3;
            } else {
                // –ó–∞–∫—Ä—ã—Ç—å —Ä–æ—Ç
                mouthOpenValue *= 0.85;
                if (mouthOpenValue < 0.01) mouthOpenValue = 0;
            }
            
            setMouthOpen(mouthOpenValue);
        }
        
        // –ú–æ—Ä–≥–∞–Ω–∏–µ –≥–ª–∞–∑
        function animateBlink() {
            blinkTimer += clock.getDelta();
            
            if (blinkTimer > nextBlinkTime) {
                blinkTimer = 0;
                nextBlinkTime = 2 + Math.random() * 4;  // –ö–∞–∂–¥—ã–µ 2-6 —Å–µ–∫—É–Ω–¥
                
                // –ë—ã—Å—Ç—Ä–æ–µ –º–æ—Ä–≥–∞–Ω–∏–µ
                morphMeshes.forEach(mesh => {
                    const dict = mesh.morphTargetDictionary;
                    const influences = mesh.morphTargetInfluences;
                    
                    ['eyesClosed', 'eyeBlinkLeft', 'eyeBlinkRight', 'eyeBlink'].forEach(name => {
                        if (dict[name] !== undefined) {
                            influences[dict[name]] = 1.0;
                            setTimeout(() => {
                                influences[dict[name]] = 0;
                            }, 120);  // 120–º—Å
                        }
                    });
                });
            }
        }

        // ============================================
        // ANIMAƒåN√ç LOOP
        // ============================================
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            if (mixer) mixer.update(delta);
            animateMouth();
            animateBlink();
            
            // –ü–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ –≥–æ–ª–æ–≤—ã –ø—Ä–∏ —Ä–∞–∑–≥–æ–≤–æ—Ä–µ
            if (model && isSpeaking) {
                model.rotation.y = Math.sin(Date.now() * 0.002) * 0.03;
                model.rotation.x = Math.sin(Date.now() * 0.0015) * 0.015;
            } else if (model) {
                model.rotation.y *= 0.95;
                model.rotation.x *= 0.95;
            }
            
            renderer.render(scene, camera);
        }
        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        // ============================================
        // TEXT-TO-SPEECH —Å Audio Analyzer
        // ============================================
        async function speak(text) {
            try {
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º AudioContext –æ–¥–∏–Ω —Ä–∞–∑
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    dataArray = new Uint8Array(analyser.frequencyBinCount);
                }
                
                // –ü–æ–ª—É—á–∞–µ–º –∞—É–¥–∏–æ
                const response = await fetch(API + '/tts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text })
                });
                
                if (!response.ok) {
                    console.error('TTS chyba:', response.status);
                    return;
                }
                
                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);
                
                // –ü–æ–¥–∫–ª—é—á–∞–µ–º analyser
                const source = audioContext.createMediaElementSource(audio);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                
                return new Promise((resolve) => {
                    audio.onplay = () => {
                        isSpeaking = true;
                        console.log('üé§ Zaƒç√≠n√° mluvit');
                    };
                    
                    audio.onended = () => {
                        isSpeaking = false;
                        URL.revokeObjectURL(audioUrl);
                        console.log('üé§ Konec mluven√≠');
                        resolve();
                    };
                    
                    audio.onerror = () => {
                        isSpeaking = false;
                        console.error('‚ùå Audio chyba');
                        resolve();
                    };
                    
                    audio.play().catch(err => {
                        console.error('Play error:', err);
                        isSpeaking = false;
                        resolve();
                    });
                });
                
            } catch (error) {
                console.error('TTS chyba:', error);
                isSpeaking = false;
            }
        }

        // ============================================
        // AI RESPONSE
        // ============================================
        async function getAIResponse(userText) {
            try {
                // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –æ—Ç–≤–µ—á–∞—Ç—å –∫—Ä–∞—Ç–∫–æ
                const promptWithInstruction = `Odpovƒõz struƒçnƒõ a jasnƒõ (max 2-3 vƒõty). ${userText}`;
                
                console.log('ü§ñ Zpracov√°v√°m:', userText);
                
                let fullText = '';
                
                // –°—Ç—Ä–∏–º–∏–Ω–≥ —Ç–µ–∫—Å—Ç–∞
                const eventSource = new EventSource(API + '/__ai_stream__?prompt=' + encodeURIComponent(promptWithInstruction));
                
                eventSource.onmessage = async (event) => {
                    const data = JSON.parse(event.data);
                    
                    if (!data.done) {
                        fullText += data.text;
                        console.log('üìù –¢–µ–∫—Å—Ç:', fullText);
                    } else {
                        eventSource.close();
                        
                        // –í–ï–°–¨ —Ç–µ–∫—Å—Ç –≥–æ—Ç–æ–≤ - —Ç–µ–ø–µ—Ä—å –æ–∑–≤—É—á–∏–≤–∞–µ–º —Å–ª–∏—Ç–Ω–æ!
                        console.log('‚úÖ –í–µ—Å—å —Ç–µ–∫—Å—Ç –≥–æ—Ç–æ–≤:', fullText);
                        await speakWholeSentence(fullText);
                    }
                };
                
                eventSource.onerror = () => {
                    eventSource.close();
                    console.error('‚ùå Chyba spojen√≠');
                };
                
            } catch (error) {
                console.error('Chyba:', error);
            }
        }
        
        // –û–∑–≤—É—á–∏–≤–∞–Ω–∏–µ –¶–ï–õ–û–ì–û —Ç–µ–∫—Å—Ç–∞ –±–µ–∑ –ø–∞—É–∑
        async function speakWholeSentence(text) {
            const WORDS_PER_CHUNK = 5;
            const words = text.trim().split(/\s+/).filter(w => w.length > 0);
            
            let audioQueue = [];  // –ì–æ—Ç–æ–≤—ã–µ –∞—É–¥–∏–æ
            let generatedCount = 0;
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Audio Analyzer
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
            }
            
            // –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ —á–∞–Ω–∫–∏
            const chunks = [];
            for (let i = 0; i < words.length; i += WORDS_PER_CHUNK) {
                chunks.push(words.slice(i, i + WORDS_PER_CHUNK).join(' '));
            }
            
            console.log('üì¶ –ì–µ–Ω–µ—Ä–∏—Ä—É—é', chunks.length, '—á–∞–Ω–∫–æ–≤');
            
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –í–°–ï –∞—É–¥–∏–æ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
            const audioPromises = chunks.map(async (chunk) => {
                const response = await fetch(API + '/tts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: chunk })
                });
                
                if (response.ok) {
                    const blob = await response.blob();
                    return { chunk, url: URL.createObjectURL(blob) };
                }
                return null;
            });
            
            // –ñ–¥—ë–º –í–°–ï –∞—É–¥–∏–æ
            audioQueue = (await Promise.all(audioPromises)).filter(a => a !== null);
            
            console.log('‚úÖ –í—Å–µ –∞—É–¥–∏–æ –≥–æ—Ç–æ–≤—ã! –ù–∞—á–∏–Ω–∞—é —Å–ª–∏—Ç–Ω–æ–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ');
            
            // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º —Å–ª–∏—Ç–Ω–æ
            for (const { chunk, url } of audioQueue) {
                await playAudioChunk(url, chunk);
            }
            
            console.log('üé§ –ó–∞–∫–æ–Ω—á–∏–ª –≥–æ–≤–æ—Ä–∏—Ç—å');
            isSpeaking = false;
        }
        
        // –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ —á–∞–Ω–∫–∞
        async function playAudioChunk(url, text) {
            return new Promise(async (resolve) => {
                console.log('üîä –ì–æ–≤–æ—Ä—é:', text);
                
                try {
                    // –ó–∞–≥—Ä—É–∂–∞–µ–º –∞—É–¥–∏–æ –∫–∞–∫ ArrayBuffer
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    
                    // –î–µ–∫–æ–¥–∏—Ä—É–µ–º –≤ AudioBuffer
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    // –°–æ–∑–¥–∞—ë–º source
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    
                    // –ü–æ–¥–∫–ª—é—á–∞–µ–º —á–µ—Ä–µ–∑ analyser
                    source.connect(analyser);
                    analyser.connect(audioContext.destination);
                    
                    // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
                    isSpeaking = true;
                    
                    // –ö–æ–≥–¥–∞ –∑–∞–∫–æ–Ω—á–∏—Ç—Å—è
                    source.onended = () => {
                        URL.revokeObjectURL(url);
                        resolve();  // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É
                    };
                    
                    // –ó–∞–ø—É—Å–∫–∞–µ–º
                    source.start(0);
                    
                } catch (err) {
                    console.error('Audio error:', err);
                    URL.revokeObjectURL(url);
                    resolve();
                }
            });
        }

        // ============================================
        // NAHR√ÅV√ÅN√ç HLASU
        // ============================================
        window.toggleRecording = async function() {
            const btn = document.getElementById('mic-btn');
            const indicator = document.getElementById('recording-indicator');
            
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    chunks = [];
                    
                    mediaRecorder.ondataavailable = e => chunks.push(e.data);
                    
                    mediaRecorder.onstop = async () => {
                        const blob = new Blob(chunks, { type: 'audio/webm' });
                        stream.getTracks().forEach(t => t.stop());
                        
                        // –°–∫—Ä—ã—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
                        indicator.classList.remove('active');
                        btn.classList.remove('recording');
                        
                        await processAudio(blob);
                    };
                    
                    mediaRecorder.start();
                    isRecording = true;
                    btn.classList.add('recording');
                    indicator.classList.add('active');
                    
                } catch (err) {
                    console.error('Mikrofon:', err);
                    alert('Nelze z√≠skat p≈ô√≠stup k mikrofonu');
                }
            } else {
                mediaRecorder.stop();
                isRecording = false;
            }
        };

        async function processAudio(blob) {
            console.log('üé§ Zpracov√°v√°m audio...');
            
            try {
                const form = new FormData();
                form.append('audio', blob, 'audio.webm');
                
                const sttResponse = await fetch(API + '/stt', {
                    method: 'POST',
                    body: form
                });
                const sttData = await sttResponse.json();
                
                if (sttData.error) {
                    console.error('STT chyba:', sttData.error);
                    return;
                }
                
                console.log('üë§ ≈òekl jsi:', sttData.text);
                await getAIResponse(sttData.text);
                
            } catch (error) {
                console.error('Chyba:', error);
            }
        }
    </script>
</body>
</html>
